# 二分查找

[二分查找总结](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/yi-wen-dai-ni-gao-ding-er-fen-cha-zhao-j-ymwl/)

两个易错点

1. 计算 `mid` 使用 `left + ((right - left)>>1)` 防止数值溢出；
2. 区间选择 `while(left < right)` or `while(left <= right)`；
3. 判断选择 `right = mid` or `right = mid - 1`；
4. 需要考虑元素是否为递增，最大值和最小值的判断，数组是否为空；
5. 二分查找有很多变种，不要一味追求代码简洁，而导致不好理解；
6. 只需要考虑到二分查找临界值的情况判定，划分好出现的情况；

区间的定义是不变量。在二分查找过程保持不变量，`while` 循环中，每次边界处理根据区间的定义来操作，这是 **循环不变量** 规则。

## 二分查找写法一

定义左闭右闭区间 `[left, right]`，特点是：

1. `left, right` 相等的情况，改区间是有意义的，所以 `while(left <= right)`。
2. `nums[mid] > target`，更新搜索范围右下标 `right = mid - 1`，因为 `nums[mid]` 不是目标值，所以左区间结束下标为 `mid - 1`。

```go
package main

func search(nums []int, target int) int {
	l, r := 0, len(nums)-1
	for l <= r { // [l,r] 左闭右闭区间
		mid := l + ((r - l) >> 2)
		if nums[mid] > target {
			r = mid - 1 // target 在左区间
		} else if nums[mid] < target {
			l = mid + 1
		} else {
			return mid
		}
	}
	return -1
}
```

## 二分查找写法二

定义左闭右开区间 `[left, right)`，特点是：

1. `left, right` 相等的情况是无意义的，所以 `while(left < right)`。
2. `nums[mid] > target` ，更新搜索范围右下标 `right = mid`，因为当前 `nums[mid]` 不是目标值，左区间为左闭右开所以结束下标为 `mid`。

```go
package main

func search(nums []int, target int) int {
	l, r := 0, len(nums)-1
	if l < r { // [l, r) 左闭右开区间
		mid := l + ((r - l) >> 2)
		if nums[mid] > target {
			r = mid // target 在左区间，左闭右开
		} else if nums[mid] < target {
			l = mid + 1
		} else {
			return mid
		}
	}
	return -1
}
```

## 变种：35.搜索插入位置

问题变为：在一个有序数组中找第一个大于等于 target 的下标。
`mid` 为最终符合条件的一个，`mid+1` 就是大于 `target` 的索引位置，`mid-1` 就是小于 `target` 的位置。 🤔最后一个临界值的条件情况。

```go
package main

func searchInsert(nums []int, target int) int {
	l, r := 0, len(nums)-1
	for l <= r {
		mid := l + ((r - l) >> 1)
		if nums[mid] == target {
			return mid
		} else if nums[mid] > target {
			r = mid - 1
		} else if nums[mid] < target {
			l = mid + 1 // mid 为最后一个小于的位置，mid + 1 后为插入的位置
		}
	}
	return l // 返回插入位置
}
```

`go` 语言 `sort.SearchInts()` 源码样例 基于上一种写法的变种，因为查找的是大于等于的索引位置

1. 临界情况一，`nums[mid] = target` 返回左区间，左区间符合 `< target` 条件的最大值 `mid`，在最终结果索引的左边，所以 `mid+1` 就是结果了。
2. 临界情况二，`nums[mid] > target` 返回左区间，左区间符合 `< target` 条件的最大值 `mid`，在最终结果所有的左边，所以 `mid+1` 就是结果了

```go
package main

func search(nums []int, target int) int {
	l, r := 0, len(nums)-1
	for l <= r {
		mid := int(uint(l+r) >> 1)
		if nums[mid] < target {
			l = mid + 1
		} else { // 将等于和大于的情况归为一类
			r = mid - 1
		}
	}
	return l
}
```

其实上述符合临界情况的 `mid` 就是结果。

```go
package main

func searchInsert(nums []int, target int) int {
	l, r := 0, len(nums)-1
	ans := len(nums) // 最大的插入位置
	for l <= r {
		mid := l + ((r - l) >> 1)
		if nums[mid] >= target {
			ans = mid
			r = mid - 1
		} else if nums[mid] < target {
			l = mid + 1
		}
	}
	return ans // 返回插入位置
}
```

## 变种：34在排序数组中查找元素的第一个和最后一个位置

基于 `35` 案例，问题可以规划为

* 寻找最左索引：查找第一个大于等于 `target` 的下标。
* 寻找最右索引：查找最后一个小于等于 `target` 的下标。
* 最左的情况，就是当 `nums[mid] == target` 返回左区间，在左区间寻找到最后一个符合 `< target` 的索引，然后加 `1`；
* 最右的情况，就是当 `nums[mid] == target` 返回右区间，在右区间寻找到第一个符合 `> target` 的索引，然后减 `1`；

## 变种：33搜索旋转排序数组

非连续递增无重复的数组，而是递增数组经过旋转得到的，只有部分数组是有序的。 将数组从中间分开左右两部分，一定有一部分数组是有序的，我们可以通过分割出来的有序数组进行判断。

⚠️ 左区间判断，是通过 `nums[l] <= nums[mid]`，而不是通过 `target <= nums[mid]`。

* 左区间：`nums[l] <= nums[mid]` 前部分有序
    1. `nums[l] <= target < nums[mid]` 目标值在左区间
    2. `target > nums[mid]`  目标值在右区间
* 右区间：
    1. `nums[mid] < target <= nums[r]` 目标值在右区间
    2. `target < nums[mid]` 目标值在左区间

🤔 如何判断左右那部分区间有序，`nums[0] <= nums[mid]` 左侧有序。

```go
package main

func search(nums []int, target int) int {
	l, r := 0, len(nums)-1
	for l <= r {
		mid := l + ((r - l) >> 1)
		if nums[mid] == target {
			return mid
		}
		if nums[l] <= nums[mid] { // 左侧有序
			if nums[l] <= target && target < nums[mid] { // 一定在左侧
				r = mid - 1
			} else { // 不在左侧从右侧找
				l = mid + 1
			}
		} else {
			if nums[mid] < target && target <= nums[r] {
				l = mid + 1
			} else {
				r = mid - 1
			}
		}
	}
	return -1
}
```

## 变种：81搜索选择排序数组II

非连续递增有重复的数组，也是递增数组经过旋转后得到的。 需要考虑的还是判断出来有序区间，但是存在重复的值，如 `3,1,2,3,3,3,3` 该数组就没办法直接判断出来那边是有序区间。

* 第一种情况：
  `10111`，`nums[l] == nums[mid]` 无法判断前有序还是后有序，此时 `l++` 就可以去掉干扰，不需要执行后续判断逻辑 `continue`。
* 第二种情况：
  `2345671` `nums[l] < nums[mid]` 前部分有序，若 `nums[l] <= target < nums[mid]` 则在前部分查找，否则就后半部分找
* 第三种情况：
  `6712345` `nums[l] > nums[mid]` 后部分有序，若 `nums[mid] < target <= nums[r]` 则在后半部分找，否则就前半部分找

```go
package main

func search(nums []int, target int) bool {
	l, r := 0, len(nums)-1
	for l <= r {
		mid := l + ((r - l) >> 1)
		if nums[mid] == target {
			return true
		}
		if nums[l] == nums[mid] {
			l++
			continue // 注意需要 continue
		}
		if nums[l] <= nums[mid] { // 前半部分有序
			if nums[l] <= target && target < nums[mid] {
				r = mid - 1
			} else {
				l = mid + 1
			}
		} else { // 后部分有序
			if nums[mid] < target && target <= nums[len(nums)-1] {
				l = mid + 1
			} else {
				r = mid - 1
			}
		}
	}
	return false
}
```

## 变种：153寻找旋转排序数组中的最小值

三种情况：

1. `nums[mid] < nums[r]` 最小值在左半边
2. `nums[mid] > nums[r]` 最小值在右半边

```go
package main

func findMin(nums []int) int {
	l, r := 0, len(nums)-1
	for l < r { // 左闭右开区间，里面始终包含最小值 终止条件为 `left <= mid < right`
		mid := l + ((r - l) >> 1) // 向下取整法 mid 更靠近 left
		if nums[mid] < nums[r] {  // 最小值在左边, 中值可能是最小值，右边界只能取到 mid
			r = mid
		} else if nums[mid] > nums[r] { // 最小值在右半边，中值肯定不是最小值，左边界可以为 mid
			l = mid + 1 // 
		}
	}
	return nums[l] // left == right 最小值都可以
}
```

`while` 退出循环的条件：

1. 数组只有一个数，左右边界重合 `left == right` 不会进入循环；
2. 数组循环到最后只有两个数，`nums[left] == nums[mid]` 以及 `nums[right]` 这里 `left == mid == right - 1`；
    1. 若 `nums[left] == nums[mid] > nums[r]` 左大右小，会执行 `l = mid + 1` 左右边界重合循环结束；
    2. 若 `nums[left] == nums[mid] < nums[r]` 左小右大，会执行 `r = mid` 左右边界重合循环结束；