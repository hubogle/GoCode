# 回溯算法

> 本质就是穷举

回溯是递归的副产品，只要有递归就会有回溯，可以理解为回溯函数和递归函数都是一个。

`N` 叉树：回溯算法都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度构成树的深度。 回溯优化：对抽象的 `N` 叉树进行减枝操作。

---

## 常见问题

* 组合问题：`N` 个数里面按一定规则找出 `k` 个数的集合
* 切割问题：一个字符串按一定规则有几种切割方式
* 子集问题：一个 `N` 个数的集合里有多少符合条件的子集
* 排列问题：`N` 个数按一定规则全排列，有几种排列方式
* 棋盘问题：`N` 皇后，解数独等等

组合不强调顺序，排列强调元素顺序。

若子集、组合、切割问题抽象为一棵树，组合和分割问题都是收集树的叶子节点，子集是收集树的所有节点。

组合和排列都是在叶子节点收集结果，子集就是在树上搜集所有节点。

---

## 回溯模板

1. 先确定终止条件；
2. 回溯搜索的遍历过程；
3. 通过逻辑来确定需要的参数；

每次 `for` 循环就是当前层的节点数，递归就是当前树的深度。

```text
func backtracking(参数) {
    if 终止条件 {
        存放结果;
        return;
    }
    for i := 0; i < 节点孩子数量; i++ { // 树的宽度，横向遍历
        处理节点;
        backtracking(路径，选择列表); // 递归操作，也是树的深度，纵向遍历
        撤销处理结果；                // 回溯操作，撤销本次处理的结果
    }
}
```

---

## 组合问题

将递归过程，抽象为树形结构（`N` 叉树）理解回溯。

* [组合](../editor/cn/77组合.go)：终止条件到达叶子节点；
* [组合总和 III](../editor/cn/216组合总和%20III.go)：相对于组合问题终止条件额外加了目标和的条件；
* [电话号码的字母组合](../editor/cn/17电话号码的字母组合.go)：主要注意 `for` 循环条件；
* [组合总和](../editor/cn/39组合总和.go)：递归结束条件是 `>=target` ，与上面的区别在于可以重复使用元素，`for` 循环 `index = i`
* [组合总和 II](../editor/cn/40组合总和%20II.go)：不能有重复组合，注意树层的去重操作，每个值只能使用一次；

### 组合问题细节

组合内可以重复，同一棵树上元素可重复； 组合不能重复，当前同一层上不能重复；

1. 组合是否有数量限制；
2. 元素是否可重复使用，决定 `for` 循环起始位置 ；
3. 给定的数组是否有重复值；
4. 给定的数组是否可以排序；
5. 树层去重需要对数组排序或者对数组内的元素（不是坐标）做 `map` 标记；

树层去重复： 可排序：`i > 0 && nums[i] == nums[i-1] && used[i-1] == false` 同一树层有重复值。
可排序：`i > 0 && nums[i] == nums[i-1] && used[i-1] == true` 同一棵树有重复值。 不可排序：每次递归申请一个 `map` 记录当前层数是否已被使用。

---

## 切割问题

> 切割问题抽象为组合问题。

* [分割回文串](../editor/cn/131分割回文串.go)：如何截取子串，`for` 循环里模拟切割线；
* [复原 IP 地址](../editor/cn/93复原%20IP%20地址.go)：主要是处理节点的逻辑，减枝操作；

---

## 子集问题

> 子集也是一种组合问题，因为集合是无序的。

* [子集](../editor/cn/78子集.go)：注意收集每个节点；
* [子集 II](../editor/cn/90子集%20II.go)：因为有重复元素，所以注意树层去重复；

不需要进行减枝操作，因为要遍历整棵树。

---

## 排列问题

* [递增子序列](../editor/cn/491递增子序列.go)：求的是子序列，有重复元素，又不能排序。所以每次递归申请一个 `map` 来标记当前层是否使用，`for` 循环下次递归每次 `index = i+1`。
* [全排列](../editor/cn/46全排列.go)：树枝去重复，`for` 循环每次从 `0` 开始。
* [全排列 II](../editor/cn/47全排列%20II.go)：


1. 每层都从 `0` 开始，而不像组合每次从当前位置，或者下一位开始；
2. `used` 来标记当前数枝去重。

对于排列问题，树层和树枝上去重都是可以的，但是树层上去重效率高。

## 棋盘问题

* [N 皇后](../editor/cn/51N%20皇后.go)：注意写处理节点的判断逻辑；
* [解数独](../editor/cn/37解数独.go)：注意要使用二维递归逻辑，不能使用单层递归逻辑；

`N` 皇后：一列只需要确定一个值，判断是否符合条件，判断上面的列。 解数独：一列需要确定当前所有列的值。