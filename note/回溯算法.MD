# 回溯算法

> 本质就是穷举

回溯是递归的副产品，只要有递归就会有回溯，可以理解为回溯函数和递归函数都是一个。

`N` 叉树：回溯算法都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度构成树的深度。

## 算法效率

回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

## 回溯模板

1. 确定回溯函数的返回值和参数
2. 回溯函数终止条件
3. 回溯搜索的遍历过程

```text
func backtracking(参数) {
    if 终止条件 {
        存放结果;
        return;
    }
    for i := 0; i < 节点孩子数量; i++ {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

`for` 循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个 `for` 循环就执行多少次。
`for` 循环可以理解是横向遍历，`backtracking`（递归）就是纵向遍历

## 解决问题

* 组合问题：`N` 个数里面按一定规则找出 `k` 个数的集合
* 切割问题：一个字符串按一定规则有几种切割方式
* 子集问题：一个 `N` 个数的集合里有多少符合条件的子集
* 排列问题：`N` 个数按一定规则全排列，有几种排列方式
* 棋盘问题：`N` 皇后，解数独等等
