# 树

## 定义

* 根节点：没有父节点
* 兄弟节点：有相同的父节点
* 叶子节点：**没有子节点**

* 高度（从下往上）：该节点到叶子节点的最长的边数
* 深度（从上往下）：根节点到该节点所经历边的个数
* 层：节点的深度 `+1`

---

## 二叉树

* 二叉树：每个节点最多有两个子节点。
* 满二叉树：一棵二叉树只有度为 `0` 的节点和度为 `2` 的节点，并且度为 `0` 的节点在同一层上。
* 完全二叉树：除最底层节点未填满外，其余每层节点都达到最大值，并且最下面一层节点都集中在最左边的位置，若最底层为 `n` 层，则该层有 `1~2^n` 个。

### 存储方式

1. 链式存储：每个节点有三个字段，一个存储数据，另外两个存储左右节点的指针。
2. 数组存储：将根节点存储在下标 `i=1` 的位置，则左节点在 `2*i` 右节点在 `2*i+1`。

完全二叉树用数组存储只浪费下标为 `0` 的存储位置，非完全二叉树则会浪费比较多的存储空间。

### 遍历方式

1. 深度优先遍历：往深走，遇到叶子节点再往回走；
    * 前序遍历（递归法，迭代法）（中左右)
    * 中序遍历（递归法，迭代法）（左中右）
    * 后序遍历（递归法，迭代法）（左右中）
2. 广度优先遍历：一层一层的遍历；
    * 层次遍历（迭代法）

---

## 二叉查找树

> 二叉查找树，为了实现快速查找数而实现的，还支持快速插入、删除数据。
> 二叉搜索树，二叉排序树（中序遍历输出有序的数组序列）

* 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
* 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
* 它的左、右子树也分别为二叉排序树；

### 二叉查找树查找操作

1. 查找的数据等于节点值；
2. 查找的数据大于节点则去右子树；

### 二叉查找树插入操作

> 新插入的数据一般都是在叶子节点上。

1. 插入数据比节点大，节点右子树为空；
2. 插入数据比节点大，节点右子树不为空，则遍历右子树，查找插入位置。

### 二叉查找树删除操作

1. 删除节点没有子节点，直接将改节点的父节点置为 `nil`；
2. 删除节点有一个子节点，更新父节点中，指向要删除节点的指针；
3. 删除节点有两个子节点，找到节点右子树中最小（左子树最大）的节点，把它替换到要删除的节点上，然后再删除；

### 支持重复数据二叉查找树

1. 节点设计为链表或支持动态扩容结构。
2. 每个节点只存储一个数据，若碰到相同的值，将值放在节点的右子树（当于大于值）处理。
    1. 查找操作：遇到相同值，继续在右子树查找直到遇到叶子节点再停止；
    2. 删除操作：查找到要删除的所有节点，然后依次删除；

---

## 平衡二叉查找树

> AVL 树（高度平衡）：一棵空树或左右两个子树高度差绝对值不超过 `1`，并且左右两个子树都是一棵平衡二叉树。
> 完全二叉树、满二叉树都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。

平衡二叉查找树：解决二叉查找树频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。

## 红黑树

> 一种不严格的平衡二叉树，做到近似平衡在维护成本上比 `AVL` 树要低。

* 根节点是黑色的；
* 每个叶子节点都是黑色的空节点，叶子节点不存储数据；
* 任何相邻的节点都不能同时为红色，红色节点被黑色节点隔开；
* 每个节点，从该节点到可达叶子节点的路径，所包含相同数目的黑色节点；

## ## 问题

1. 给定一组数据无重复值，可构建出多少中不同的二叉树？
2. 二叉查找树相对散列表的优势。
    1. 散列表数据无序，二叉查找树中序遍历输出的有序；
    2. 散列表扩容耗时多，遇到散列冲突性能不稳定，平衡二叉查找树性能稳定；
    3. 散列表因为哈希冲突，实际查找效率肯小于 `O(logn)`；
    4. 散列函数设计要考虑，冲突、扩容、缩容，平衡二叉查找树只需要考虑平衡性；